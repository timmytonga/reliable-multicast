//
// Created by Thien Nguyen on 10/12/20.
//

#ifndef PRJ1_CL_GLOBAL_SNAPSHOT_H
#define PRJ1_CL_GLOBAL_SNAPSHOT_H

#include <map>
#include <mutex>
#include <sstream>
#include <queue>

#include "networkagent.h"

#define SNAP_SHOT_PORT 9345
#define MAX_MARKER_SIZE 3
#define INBOUND 1
#define OUTBOUND 2
#define MAX_STRUCT_SIZE     20  // 20 bytes for 5 uint32_t

#define DUPPRINT(fp, fmt...) do {printf(fmt);fprintf(fp,fmt);} while(0)

class ReliableMulticast;
typedef std::vector<unsigned char> ByteVector;


typedef struct {
    uint32_t        sequence_number;
    unsigned char   status;     // 0 means undeliverable while 1 means deliverable
    uint32_t        sender;    // sender's id
    uint32_t        msg_id;    // the id of message generated by sender
    uint32_t        data;      // a dummy integer
    uint32_t        proposer;      // process id of proposer
} QueuedMessage;


/* for global snapshot */
typedef struct {
    std::vector<QueuedMessage> deliveryQueue;       // [SHARED BY THREADS]
    std::vector<QueuedMessage> deliveredMessage;  // this is to hold the final delivered msg
} LocalStateSnapshot;

class CL_Global_Snapshot{
    /* each object will be created as a snapshot daemon ready to either initiate a snapshot or response to one
     * -- they will be setup as a listening TCP connection
     * -- then when the initiator wants to initiate a snapshot, it will prompt those daemons to accept the connection
     * -- in which a channel is created for communicating.
     * It's then when each receiving daemon will receive a marker (from the initiator)
     * It will then invoke the object that it's keeping track of to send a snapshot of the state
     * It would also inform the object to record incoming messages on its channel
     * Then it sends out a marker to everybody */
public:
    explicit CL_Global_Snapshot(ReliableMulticast *rm, const client_server::TCP_Server& server);
    explicit CL_Global_Snapshot(ReliableMulticast *rm);

    ~CL_Global_Snapshot();

    int initiate_snapshot();
    void listen_for_incoming_connections();

    // logistic var
    LocalStateSnapshot locsnap;
    int num_hosts;
    char ** hostNames;
    int curr_container_id;
    const char * curr_container_name;
    bool amInitiator;
    ReliableMulticast* rm;
    // communication var
    client_server::TCP_Server server;
//    std::map<int, int> hostToSockFD;  // this is to map hostID to its sock descriptor
//    std::mutex hostToSockMutex;
    std::vector<int> alreadyReceivedProc;
    // for recording and communicating with rm
    std::queue<ByteVector> inboundMessageBuffer;
    std::mutex inboundMessageBufferMutex;
    std::queue<ByteVector> outboundMessageBuffer;
    std::mutex outboundMessageBufferMutex;

    std::map<int, std::vector<std::string>> inboundChannelState;
    std::map<int, std::vector<std::string>> outboundChannelState;
    // for outputting



    // function
    void tell_rm_to_start_recording_channel() const;
    void tell_rm_to_stop_recording() const;
    void broadcast_markers() const;
    void add_msg_to_inbound(int id, const std::string& s);
    void add_msg_to_outbound(int id, const std::string& s);
    void set_rm(ReliableMulticast *rm);

    void handle_message(unsigned char *msg, int inorout);
    void print_local_snapshot();

    friend class ReliableMulticast;
};


#endif //PRJ1_CL_GLOBAL_SNAPSHOT_H
