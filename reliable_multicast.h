//
// Created by Thien Nguyen on 10/8/20.
//

#ifndef PRJ1_RELIABLE_MULTICAST_H
#define PRJ1_RELIABLE_MULTICAST_H

#include <cstdint>
#include <cstring>
#include <string>
#include <queue>
#include <functional>
#include <thread>
#include <map>

#include "networkagent.h"
#include "waittosync.h"

#define SERVER_PORT 4646
#define MAX_MSG_SIZE 256
#define MAX_NUM_HOSTS 16  // max 16 hosts
#define MAX_HOST_NAME 256
#define MAX_STRUCT_SIZE 20  // 20 bytes for 5 uint32_t
#define RECV_CAP 500  // for debugging

#define UNDELIVERABLE 0
#define DELIVERABLE 1
#define DATAMSG_TYPE 1
#define ACKMSG_TYPE 2
#define SEQMSG_TYPE 3


typedef struct {
    uint32_t type;      // must be 1
    uint32_t sender;    // sender's id
    uint32_t msg_id;    // the id of message generated by sender
    uint32_t data;      // a dummy integer
} DataMessage;

typedef struct {
    uint32_t type;          // must be 2
    uint32_t sender;        // sender of DataMessage
    uint32_t msg_id;        // the id of Datamessage generated by sender
    uint32_t proposed_seq;  // proposed sequence number
    uint32_t proposer;      // process id of proposer
} AckMessage;


typedef struct {
    uint32_t type;                  // must be 3
    uint32_t sender;                // sender of DataMessage
    uint32_t msg_id;                // the id of Datamessage generated by sender
    uint32_t final_seq;             // proposed sequence number
    uint32_t final_seq_proposer;    // process id of proposer who poposed the final seq
} SeqMessage;

typedef struct {
    uint32_t        sequence_number;
    unsigned char   status;     // 0 means undeliverable while 1 means deliverable
    uint32_t        sender;    // sender's id
    uint32_t        msg_id;    // the id of message generated by sender
    uint32_t        data;      // a dummy integer
    uint32_t        proposer;      // process id of proposer
} QueuedMessage;


void packi32(unsigned char *buf, unsigned long int i);
unsigned long int unpacku32(unsigned char *buf);
void serialize_data_message(const DataMessage &dataMessage, unsigned char * buf);
void deserialize_data_message(unsigned char * buf, DataMessage &dataMessage);
void serialize_ack_message(const AckMessage &ackMessage, unsigned char * buf);
void deserialize_ack_message(unsigned char * buf, AckMessage &ackMessage);
void serialize_seq_message(const SeqMessage &seqMessage, unsigned char * buf);
void deserialize_seq_message(unsigned char * buf, SeqMessage &seqMessage);
int extract_int_from_string(std::string str);

class mycomparison{
public:
    bool operator() (QueuedMessage left, QueuedMessage right){
        return left.sequence_number > right.sequence_number;
    }
};

class ReliableMulticast{
public:
    ReliableMulticast(const char *hostfile, const udp_client_server::UDP_Server& communicator);
    ~ReliableMulticast();

    // thread function
    void handle_datamsg(const DataMessage &dataMessage);
    void handle_ackmsg(const AckMessage &ackMessage);
    void handle_seqmsg(const SeqMessage &seqMessage);
    void multicast_datamsg(uint32_t data);
    void static start_msg_receiver(ReliableMulticast* rm);  // for use in a thread

private:
    typedef std::map<int, int> ProposerSeq;
    /* private attributes */
    int num_hosts = 0;          // read by threads?
    const char * current_container_name = nullptr;
    int current_container_id;
    int curr_msg_id = 0;
    int curr_seq_number = 1;
    char** hostNames;
    udp_client_server::UDP_Server communicator;
    std::priority_queue<QueuedMessage, std::vector<QueuedMessage>, mycomparison> deliveryQueue;
    std::vector<ProposerSeq> ackHistory;  // ackHistory[msg_id][

    int recv_cap = 1;
    // function
    [[noreturn]] void msg_receiver();
};


#endif //PRJ1_RELIABLE_MULTICAST_H
