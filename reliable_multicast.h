//
// Created by Thien Nguyen on 10/8/20.
//

#ifndef PRJ1_RELIABLE_MULTICAST_H
#define PRJ1_RELIABLE_MULTICAST_H

//#define DEBUG

#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <string>
#include <queue>
#include <functional>
#include <thread>
#include <mutex>  // std::mutex
#include <map>
#include <chrono>  // for sleep

#include "networkagent.h"
#include "waittosync.h"

#define SERVER_PORT 4646
#define MAX_MSG_SIZE 256
#define MAX_NUM_HOSTS 16  // max 16 hosts
#define MAX_HOST_NAME 256
#define MAX_STRUCT_SIZE 20  // 20 bytes for 5 uint32_t
#define RECV_CAP 5000  // for debugging

#define UNDELIVERABLE 0
#define DELIVERABLE 1
#define DATAMSG_TYPE 1
#define ACKMSG_TYPE 2
#define SEQMSG_TYPE 3


typedef struct {
    uint32_t type;      // must be 1
    uint32_t sender;    // sender's id
    uint32_t msg_id;    // the id of message generated by sender
    uint32_t data;      // a dummy integer
} DataMessage;


typedef struct {
    uint32_t type;          // must be 2
    uint32_t sender;        // sender of DataMessage
    uint32_t msg_id;        // the id of Datamessage generated by sender
    uint32_t proposed_seq;  // proposed sequence number
    uint32_t proposer;      // process id of proposer
} AckMessage;


typedef struct {
    uint32_t type;                  // must be 3
    uint32_t sender;                // sender of DataMessage
    uint32_t msg_id;                // the id of Datamessage generated by sender
    uint32_t final_seq;             // proposed sequence number
    uint32_t final_seq_proposer;    // process id of proposer who poposed the final seq
} SeqMessage;


typedef struct {
    uint32_t        sequence_number;
    unsigned char   status;     // 0 means undeliverable while 1 means deliverable
    uint32_t        sender;    // sender's id
    uint32_t        msg_id;    // the id of message generated by sender
    uint32_t        data;      // a dummy integer
    uint32_t        proposer;      // process id of proposer
} QueuedMessage;


void packi32(unsigned char *buf, unsigned long int i);
unsigned long int unpacku32(unsigned char *buf);
void serialize_data_message(const DataMessage &dataMessage, unsigned char * buf);
void deserialize_data_message(unsigned char * buf, DataMessage &dataMessage);
void serialize_ack_message(const AckMessage &ackMessage, unsigned char * buf);
void deserialize_ack_message(unsigned char * buf, AckMessage &ackMessage);
void serialize_seq_message(const SeqMessage &seqMessage, unsigned char * buf);
void deserialize_seq_message(unsigned char * buf, SeqMessage &seqMessage);
int extract_int_from_string(std::string str);


auto cmp = [](QueuedMessage left, QueuedMessage right){
    return left.sequence_number == right.sequence_number ?
           left.sender > right.sender : left.sequence_number > right.sequence_number;
};


class ReliableMulticast{
public:
    ReliableMulticast(const char *hostfile,
                      const udp_client_server::UDP_Server& communicator,
                      double drop_rate = 0.0, int delay_in_ms=0);
    ~ReliableMulticast();

    // thread function
    void handle_datamsg(const DataMessage &dataMessage);
    void handle_ackmsg(const AckMessage &ackMessage);
    void handle_seqmsg(const SeqMessage &seqMessage);
    void multicast_datamsg(uint32_t data);
    void static start_msg_receiver(ReliableMulticast* rm);  // for use in a thread
private:
    typedef std::map<int, int> ProposerSeq;
    /* private attributes */
    int num_hosts = 0;          // read by threads?
    const char * current_container_name = nullptr;
    int current_container_id;
    int curr_msg_id = 0;
    int curr_seq_number = 1;
    char** hostNames;
    udp_client_server::UDP_Server communicator;
    std::vector<QueuedMessage> deliveryQueue;
    std::mutex deliveryQueueMutex;
    std::vector<QueuedMessage> deliveredMessage;  // this is to hold the final delivered msg
    std::map<int, ProposerSeq> ackHistory;  // ackHistory[msg_id] --> access
    std::map<int, int> dataHistory;  // to store the data of sent items
    std::mutex ackHistoryMutex;  // protect ackHistory: sending thread create new entry and rcving threads modifying curr
    std::mutex dataHistoryMutex;  // protect dataHistory
    int recv_cap = 1;
    // for help with testing variables
    double drop_rate;
    int delay_in_ms;
    std::mutex testing_param_mutex;

    // function
    [[noreturn]] void msg_receiver();
    void broadcast_seq_msg(const SeqMessage &seqMessage);  // simply send seqMessage to everybody
    static std::pair<uint32_t, uint32_t> get_max_sequence_from_proposerseq_map(const ProposerSeq &pm);
    static AckMessage make_ack_msg(uint32_t sender, uint32_t msg_id, uint32_t proposed_seq, uint32_t proposer);
    static SeqMessage make_seq_msg(uint32_t sender, uint32_t msg_id, uint32_t final_seq, uint32_t final_seq_proposer);
    static QueuedMessage make_queued_msg(uint32_t sequence_number, unsigned char status, uint32_t sender,
                                         uint32_t msg_id, uint32_t data, uint32_t proposer);
    int change_queued_msg_seq_and_status(uint32_t sender, uint32_t msg_id, uint32_t seq_to_change, uint32_t seq_proposer, unsigned char status);
    void push_msg_to_deliveryqueue(QueuedMessage qm);
    void deliver_msg_from_deliveryqueue();
    void print_delivery_queue();
    void print_delivered_messages();
    void print_ack_history();
    static double random_uniform_from_0_to_1();
    int send_msg_with_drop_and_delay(const char *hostname, unsigned char (&serialized_packet)[MAX_STRUCT_SIZE]);  // this is to implement extra testing for sending

};


#endif //PRJ1_RELIABLE_MULTICAST_H
