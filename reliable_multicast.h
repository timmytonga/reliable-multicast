//
// Created by Thien Nguyen on 10/8/20.
//

#ifndef PRJ1_RELIABLE_MULTICAST_H
#define PRJ1_RELIABLE_MULTICAST_H

#include <cstdint>
#include <cstring>
#include <string>
#include <queue>
#include <functional>

#include "networkagent.h"
#include "waittosync.h"
#include "serializer.h"

#define SERVER_PORT 4646
#define MAX_MSG_SIZE 256
#define MAX_NUM_HOSTS 16  // max 16 hosts
#define MAX_HOST_NAME 256
#define MAX_STRUCT_SIZE 20  // 20 bytes for 5 uint32_t


typedef struct {
    uint32_t type;      // must be 1
    uint32_t sender;    // sender's id
    uint32_t msg_id;    // the id of message generated by sender
    uint32_t data;      // a dummy integer
} DataMessage;

typedef struct {
    uint32_t type;          // must be 2
    uint32_t sender;        // sender of DataMessage
    uint32_t msg_id;        // the id of Datamessage generated by sender
    uint32_t proposed_seq;  // proposed sequence number
    uint32_t proposer;      // process id of proposer
} AckMessage;


typedef struct {
    uint32_t type;                  // must be 3
    uint32_t sender;                // sender of DataMessage
    uint32_t msg_id;                // the id of Datamessage generated by sender
    uint32_t final_seq;             // proposed sequence number
    uint32_t final_seq_proposer;    // process id of proposer who poposed the final seq
} SeqMessage;

typedef struct {
    uint32_t        sequence_number;
    unsigned char   status;     // 0 means undeliverable while 1 means deliverable
    uint32_t        sender;    // sender's id
    uint32_t        msg_id;    // the id of message generated by sender
    uint32_t        data;      // a dummy integer
    uint32_t        proposer;      // process id of proposer
} QueuedMessage;


void serialize_data_message(const DataMessage &dataMessage, unsigned char * buf){
    packi32(&buf[0], dataMessage.type);
    packi32(&buf[4], dataMessage.sender);
    packi32(&buf[8], dataMessage.msg_id);
    packi32(&buf[12], dataMessage.data);
}

void deserialize_data_message(unsigned char * buf, DataMessage &dataMessage){
    dataMessage.type = unpacku32(&buf[0]);
    dataMessage.sender = unpacku32(&buf[4]);
    dataMessage.msg_id = unpacku32(&buf[8]);
    dataMessage.data = unpacku32(&buf[12]);
}

void serialize_ack_message(const AckMessage &ackMessage, unsigned char * buf){
    packi32(&buf[0], ackMessage.type);
    packi32(&buf[4], ackMessage.sender);
    packi32(&buf[8], ackMessage.msg_id);
    packi32(&buf[12], ackMessage.proposed_seq);
    packi32(&buf[16], ackMessage.proposer);
}

void deserialize_ack_message(unsigned char * buf, AckMessage &ackMessage){
    ackMessage.type = unpacku32(&buf[0]);
    ackMessage.sender = unpacku32(&buf[4]);
    ackMessage.msg_id = unpacku32(&buf[8]);
    ackMessage.proposed_seq = unpacku32(&buf[12]);
    ackMessage.proposer = unpacku32(&buf[16]);
}

void serialize_seq_message(const SeqMessage &seqMessage, unsigned char * buf){
    packi32(&buf[0], seqMessage.type);
    packi32(&buf[4], seqMessage.sender);
    packi32(&buf[8], seqMessage.msg_id);
    packi32(&buf[12], seqMessage.final_seq);
    packi32(&buf[16], seqMessage.final_seq_proposer);
}

void deserialize_seq_message(unsigned char * buf, SeqMessage &seqMessage){
    seqMessage.type = unpacku32(&buf[0]);
    seqMessage.sender = unpacku32(&buf[4]);
    seqMessage.msg_id = unpacku32(&buf[8]);
    seqMessage.final_seq = unpacku32(&buf[12]);
    seqMessage.final_seq_proposer = unpacku32(&buf[16]);
}


auto cmp = [](QueuedMessage left, QueuedMessage right){
    return left.sequence_number > right.sequence_number;
};

class ReliableMulticast{
public:
    ReliableMulticast(const char *hostfile, const udp_client_server::UDP_Server& communicator);
    ~ReliableMulticast();

    // thread function
    [[noreturn]] void msg_receiver();
    void handle_datamsg(const DataMessage &dataMessage);
    void handle_ackmsg(const AckMessage &ackMessage);
    void handle_seqmsg(const SeqMessage &seqMessage);
    void multicast_datamsg(uint32_t data);

    // utils
    void static handle_param(int argc,  char* argv[]);
    int static extract_int_from_string(std::string str);

private:
    /* set by user */
    int num_hosts = 0;          // read by threads?

    const char * current_container_name = nullptr;
    int current_container_id;
    int curr_msg_id = 1;
    char** hostNames;
    udp_client_server::UDP_Server communicator;
    std::priority_queue<QueuedMessage, std::vector<QueuedMessage>, decltype(cmp)> q;
};


#endif //PRJ1_RELIABLE_MULTICAST_H
